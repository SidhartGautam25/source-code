

'use strict';


var pathRegexp = require('path-to-regexp');
var debug = require('debug')('express:router:layer');


var hasOwnProperty = Object.prototype.hasOwnProperty;
//hasOwnProperty is a method available on all JavaScript objects, and it is used to check whether an object
// has a property with a specified name. The reason it's assigned to a local variable is for performance and to avoid
// potential issues with shadowing.


module.exports = Layer;
/*

we can visualize layer as an object or class which contains information about a specific middleware function,
route handler, or router at a particular path within the application

const middlewareLayer = {
  handle: (req, res, next) => {
    console.log('Middleware Logic');
    next();
  },
  path: '/example',
  // ... additional properties
};
*/


// This Layer function is a constructor used to create instances of layers in the Express.js routing system. It's responsible for 
// initializing a layer with information such as the path, options, and the handle (middleware or route handler function). 
// Let's break down the function and explain each part:
function Layer(path, options, fn) {

  // Ensure the function is called with 'new' keyword
  if (!(this instanceof Layer)) {
    return new Layer(path, options, fn);
  }

  debug('new %o', path)
  // Extract options or default to an empty object
  var opts = options || {};

  // Set the handle (middleware or route handler) for the layer
  this.handle = fn;

  // Set the name of the layer based on the function name or default to '<anonymous>'
  this.name = fn.name || '<anonymous>';


 /*
  app.get('/users/:id', (req, res) => {
    // The route path is '/users/:id', and it matches '/users/123'
    // req.params will contain { id: '123' }
    // req.path will be '/users/123'
    res.send(`User ID: ${req.params.id}`);
  });
  */
  this.params = undefined;
  this.path = undefined;

  this.regexp = pathRegexp(path, this.keys = [], opts);
  // pathRegexp is a function responsible for converting the route path string into a
  // regular expression that can be used to match incoming requests.
  // this.keys is an array that will be populated with information about the route parameters.
  // For example, if the route path is /users/:id, this.keys will contain an object { name: 'id', ... }.
  // opts is an object containing options for configuring the behavior of the regular expression.
 /*
  this.regexp:
          This property is used to store the compiled regular expression based on the route path.
          The regular expression is generated by pathRegexp and takes into account the dynamic parts of the route path, such as parameters.
*/
/**
 * app.get('/users/:id', (req, res) => {}
 * 
 * // The route path is /users/:id, which includes a parameter id.
   // this.regexp is used to generate a regular expression to match paths like /users/123, where 123 can be any value.
   // this.keys will contain information about the parameter, such as its name (id).
 * 
  
});
 */

  // set fast path flags
  this.regexp.fast_star = path === '*'
  this.regexp.fast_slash = path === '/' && opts.end === false
  /**
   * In Express, these lines set flags (fast_star and fast_slash) on the this.regexp object. 
   * These flags are used as optimizations to handle special cases more efficiently.

     this.regexp.fast_star = path === '*':
              This line checks if the route path is exactly equal to '*' (a wildcard path). If true, it sets this.regexp.fast_star to true.
              This flag is used as an optimization for paths like '*' where any path matches. It allows Express to skip unnecessary processing
              when handling wildcard routes.

     this.regexp.fast_slash = path === '/' && opts.end === false:
              This line checks if the route path is exactly equal to '/' and the opts.end option is explicitly set to false.
               If true, it sets this.regexp.fast_slash to true.
              This flag is used as an optimization for paths like '/' when the end option is set to false.
               It allows Express to skip certain checks related to the end of the path.
   */
}

//It is responsible for handling errors that occur during the processing of a middleware layer.
Layer.prototype.handle_error = function handle_error(error, req, res, next) {
  var fn = this.handle;
  
  // Check if the number of parameters the middleware function expects is not equal to 4.
  // In Express, error-handling middleware typically has four parameters (error, req, res, next).
  // If the error handler doesn't have exactly four parameters, it's considered not a standard error handler.
  if (fn.length !== 4) {
    // not a standard error handler
    return next(error);
  }

  try {
    // Call the error handler function with the error, request, response, and next parameters.
    fn(error, req, res, next);
  } catch (err) {
    next(err);
  }
};

// handle the request
Layer.prototype.handle_request = function handle(req, res, next) {
  var fn = this.handle;

  if (fn.length > 3) {
    // not a standard request handler
    return next();
  }

  try {
    //call the function which this layer has 
    fn(req, res, next);
  } catch (err) {
    next(err);
  }
};


Layer.prototype.match = function match(path) {
  var match

  if (path != null) {
    // fast path non-ending match for / (any path matches)
    if (this.regexp.fast_slash) {
      /**
       * This condition checks whether the stored regular expression indicates a fast path for a non-ending match for /.
       *  This means that any path matches this layer.

        this.params = {}: If the condition is true, it sets the params property of the Layer instance to an empty object.
        This is done because in this case, there are no named parameters in the path; the layer matches any path.

        this.path = '': It sets the path property to an empty string because, again, any path matches,
        and there's no need to store a specific matched path.

        return true: The function returns true to indicate that the path matches the layer.
       */
      this.params = {}
      this.path = ''
      return true
    }

    // fast path for * (everything matched in a param)
    if (this.regexp.fast_star) {
      //uses decode_param function and then stores it in param object and make it available using req.params[0]
      this.params = {'0': decode_param(path)}
      this.path = path
      return true
    }

    // match the path
    //This variable will hold the result of the exec method. It will be an array if there's a match, or null if there's no match.
    match = this.regexp.exec(path)
    //regexp.exec(path)
    //      This is a method of the regular expression object (this.regexp). It attempts to match the regular expression against the provided path
  }
  
  //if null,it means that exec is unable to match the path to the regular expression,so that is invalid path,
  //hence,params and path becomes undefined and return false beacuse that path is invalid
  if (!match) {
    this.params = undefined;
    this.path = undefined;
    return false;
  }

  // store values
  this.params = {};
  this.path = match[0] //The match variable will contain an array with the full match at index 0 and captured groups at subsequent indices

  var keys = this.keys; //we have route parameters in keys
  var params = this.params;

  /**
   * var path = '/users/:userId/posts/:postId';
     var regexp = pathToRegexp(path, [], { end: false });
     var match = regexp.exec('/users/123/posts/456');

     match array will look like ===>
           [
                  '/users/123/posts/456',  // The entire matched path
                  '123',                   // Value captured by the first capturing group (:userId)
                  '456'                    // Value captured by the second capturing group (:postId)
            ]
            // so we can see that match array contain values of keys like userid and postid because they start with :
   */
  // so this for loop will capture those parameters and store them in params
  for (var i = 1; i < match.length; i++) {
    var key = keys[i - 1];
    var prop = key.name;
    var val = decode_param(match[i])

    if (val !== undefined || !(hasOwnProperty.call(params, prop))) {
      params[prop] = val;
    }
  }

  return true;
};

// this function simply decode the encoded url
function decode_param(val) {
  // val should be string and its length should be greater than 0
  if (typeof val !== 'string' || val.length === 0) {
    return val;
  }

  try {
    return decodeURIComponent(val);
  } catch (err) {
    if (err instanceof URIError) {
      err.message = 'Failed to decode param \'' + val + '\'';
      err.status = err.statusCode = 400;
    }

    throw err;
  }
}